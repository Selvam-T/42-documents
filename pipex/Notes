Pipex external C library functions notes -

--------------------------------------------------------------------------------
open, close, read, write,
malloc, free, perror,
strerror, access, dup, dup2,
execve, exit, fork, pipe,
unlink, wait, waitpid
--------------------------------------------------------------------------------

perror:
	#include <stdio.h>
	#include <string.h>
	
	C library function, not a shell command
	print a description for the last error that occurred during a function call, 
	example: open(), read(), dup2() etc.
	
	operates on 'errno' value, which is a global variable
	looks up error message associated with that code
	from the system's error message database.
	
	example:
	if (file_descriptor == -1){
		perror("Error opening file");
		//outputs: Error opening file: Permission denied
		return 1;
	}
	
strerror:
	#include <stdio.h>
	#include <string.h>
	
	C library function
	returns a pointer to the textual representation of the current errno value,
	which represnts an error code, it looks up the system's error message database.

	strerror() is specifically designed to retrieve error messages corresponding to 
	error numbers generated by system calls.

	it takes 'errno' value as an argument and returns a pointer to the corresponding error msg
	
	example:
	const char *error_message = strerror(error_code);
	
	if (access(path, F_OK) == -1)
	{
		printf("Access error: %s\n", strerror(errno));
		//outputs: Access error: Permission denied
	}
	
access:
	#include <unistd.h>
	
	check if a file or directory exists and 
	whether the calling process has permission to access it
	
	takes 2 arguments
		file or directory path + mode
		where mode --> F_OK, R_OK, W_OK, X_OK
		F_OK tests for the existence of the file.
		R_OK, W_OK, and X_OK test whether the file exists 
		and grants read, write, and execute permissions, respectively.
	
	function returns a 0, if file exists, permissions are granted
	returns -1. indicating an error
	
	example:
	if (access(file_path, X_OK) == 0) { 
	}
	//note X_OK checks if file exists and is executable
	
dup:
	#include <unistd.h>
	
	used to duplicate a open file descriptor
	
	takes open file descriptor as an argument and returns a new file descriptor
	that refers to the same open file, allowing multiple file descriptors to point
	to the same file.
	
	new file descriptor is the lowest-numbered file descriptor that is not currently open
	
	used to redirect standard input, output, or error streams by duplicating them to other
	file descriptors
	
	example:
	int new_fd1 = dup(file_descriptor);
	
dup2:
	#include <unistd.h>
	
	as above, but it allows the programmer to specify the new file descriptor number
	
	takes 2 arguments, the source file descriptor, and the destination file descriptor
	
	if the destination file descriptor is already in use, 'dup2' will close it first
	before duplicating the source file descriptor to the destination
	
	this function is often used to precisely control where a duplicated file descriptor
	should point.
	
	example:
	int new_fd1 = dup(file_descriptor, 4);
	
	how to read dup() argument order?
	dup(fd NOT used, fd used);

execve:
	#include <unistd.h>
	
	system call
	used to execute a new program in the current process.
	
	loads and replaces the current process image with the specified program,
	effectively starting a new program.
	
	takes 3 arguments:
		path/filename of the program to be executed,
		array of command-line arguments
		array of environment variables
		
	after a successful call to 'execve', the current process is replaced by the
	new program, and the new program begins executing with the provided arguments
	and environment variables.
	if 'execve' fails to execute the new program, it returns -1, and the current
	process remains unchanged
	
	example:
	if (child_pid == 0) {
		execve(program_path, argumentssys/types.h, environment);
		
	}
	
	 By default, commands executed via execve() will read their input from the 
	 default standard input unless it's redirected to another file descriptor 
	 using functions like dup2() to change where standard input points.
	
	Do we need to provide environment variable for all Unix command that we want
	to execute? Do some commands need, and others don't?
	Review the official documentation of man pages for the specific command. Some
	commands explicitly mention their reliance on certain environment variables.
	Example of Unix command that rely on Environment variable:
	 	'gcc' or 'g++'
	 	rely on environment variables like' PATH', 'LD_LIBRARY_PATH', 
	 	'C_INCLUDE_PATH' etc., to locate libraries, headers, and other
	 	necessary for compilation.
exit:
	used to teminate the current process and return the status code to the 
	parent process or OS.
	
	exit(EXIT_FAILURE); -->EXIT_FAILURE is a constant that returns some value
	exit(0) --> for our purpose we can use specific numbers to denote the type of error
	
fork:
	#include <sys/types.h>
       	#include <unistd.h>
   	pid_t fork(void);	

	used to create a new process, known as a child process, by duplicating 
	the current process, known as the parent process
	
	child process is an exact copy of the parent process, including code, data
	and the file descriptors, but it has a different process ID.
	
	after a successful call to 'fork', both the parent and child processes continue
	executing from the point where 'fork' was called. However, they can differentiate
	themselves by examining the return value of 'fork'
	
	in the parent process, 'fork' returns the process ID of the newly created child,
	while in the child process, it returns 0. This allows processes to determine their
	roles and execute different code paths.
	
	example:
	pid_t child_pid = fork();
	
	if (child_pid == 0) {
		//read();
	} else if (child_pid > 0){
		//write()
	}
	
pipe:
	#include <unistd.h>
	
	used to create an interprocess communication (IPC) mechanism called a pipe.
	unidirectional data channel that allows one-way communication between processes.
	
	creates a pair of file descriptors:
		one for reading from the pipe (the read end) 
		one for writing to the pipe (the write end)
	Processes can use these file descriptors to send data from one process to another.
	
	Pipes are commonly used for communication between parent and child processes or
	between related processes.
	
	example:
	int pipe_fd[2];
	
	pipe(pipe_fd);
			
unlink:	
	used to remove a link to a file in the file system, often used to delete files
	
	when 'unlink' is called with a filename as its argument, it removes the directory
	entry pointing to the file, reducing the referencing count. If the reference count
	reaches zero, the files data blocks are released, and the file is deleted.
	
wait:
	used to make a parent process wait for the termination of one of its child processes
	
	when a process creates a child using 'fork', it can use 'wait' to pause its
	execution until the child process finishes
	
	'wait' suspends the calling process until a child process terminates
	
	after the child process finishes, 'wait' returns the child's process ID (PID)
	and status information
	
	the parent can use the status information to determine how the child process exited
	and take appropriate actions
	
waitpid:
	#include <sys/types.h>
       	#include <sys/wait.h>
	
	same as above, but it provides more control and flexibility than 'wait'
	
	it allows a parent process to specify which child process it wants to wait for
	by specifying the child's PID.
--------------------------------------------------------------------------------

What does this project teach me?
process management, program execution, and handling data
--------------------------------------------------------------------------------
How does Unix command pass data to each other via pipes and input/output redirection?

File Descriptors:
	unix associates input with the terminal keyboard, 
	output with terminal display by default
	
	writing to "display" is really writing to the file that manages 
	the display of data
	
	reading data from the keyboads means reading data from the file 
	that represents the keyboard
	
	data flows via streams that transfer data from one area to another.
	each stream has specific file descriptor, stdin (0), stdout(1), stderr(2)
	
	the streams simply deal with file descriptors
	the process only needs to handle the file descriptor, not the file itself
	kernel safely manages the file
	
	all processes use these channels for input and output operations.

Data Flow:
	process gets created for each command
	
	each command's process needs to know 
		what data to take in and output
		where to send and receive such data
		
		stdin(0) ---->[in] command's process [out if no error]----> stdout(1)
					 		[out if error]----> stderr(2)
	
	if a command doesn't accept input from stdin, then the data passed to 
	such a command will simply be ignored
	example: < infile ls
		will simple ls the files and dir, ignore the input from infile
	
	example of a command that takes no imput, and gives no output:
		mv filex filey
	
	How to control the flow of input and output?
		1) using pipes, allow the ouput of one process to be 
		passed as input into another process
		2) using I/O redirection, allows files to be the source 
		and destination of data instead of default keyboard and terminal.

Pipes:
	allow data from one process to be passed to another, so that commands
	can be chained together by their streams
	
	each command in the pipeline is run in a seperate process,
	each with a separate memory space.
	
	implementation:
	pipes are buffered streams that are associated with 2 file descriptors
	
	int fd[2]; -->	fd[0] = 3, fd[1] = 4
	pipe(fd); -->	populates the array with 2 available file descriptors
			fd[0] can read in data written to fd[1]
			in otherwords, fd[0] is the read end, fd[1] is the write end.
			i.e., the left side of pipe is the write end
			right side of peipe is the read end
		
	stdin(0) --> sort -->(4)Pipe(3)-->grep ea -->stdout(1)
		sort is receiving input via fd(0), the strings are sorted, 
		sent as output via stdout, which is fed into the pipe via fd(4) 
		instead of to the terminal.
		
		note the fd(0) in the sort side, and fd(1) on the grep side are not
		on the same file descriptor table. the fd(1) on the sort side, not shown
		in the graph, feeds to fd(4).
		
		left side of pipe is the 'writable end', where the first sort process writes to
		right side of pipe is the 'readble end', where the second grep process reads from
	
	1, pipe(fd); --> pipe is opened before fork();
	2, fork(); --> creates a new process that is a copy of the current one.
	Both the parent and child processes have their own separate memory spaces, but they share 
	file descriptors that were open before the fork.
	
	Each process gets its own file descriptor table.
	including stdin, stdout, stderr.

	The data passed to the pipe sits, until all the data is received, then it drains
	into the next process.	
	i.e. Data written to the write end of the pipe is buffered by the kernel
	until it is read from the read end of the pipe.
	
	Can a fork(); inherit more than 1 pipeline?
	Yes. Example, in a chat application, you need bi-directional pipeline.
	So you need to declare 2 pipes.
--------------------------------------------------------------------------------	
	What is the hierarchy of processes that run such commands?		
	
	Parent does any required setup and creates a child process via a fork() call.
	This creates a clone of the parent's memory state and file descriptors.
	
	Child ends up with an independent copy of the variables and file descriptors
	that existed in the parent at the time of the fork() call.
	
	After the fork() changes to the parent process, it will not be visible to the child
	process and vice versa.

	Have a different child process execute each command. 
	(exception, running a built-in command, which can run in the parent process).	
	
--------------------------------------------------------------------------------
	Parent process:
	
	begins with fork() function call.
	
	if pid == 0, child process begins --> see below
	
	after the child process is complete, parent closes fds[0],
	note fds[0] is unused in the parent, because parent reads from stdin(0).
	Parent only needs to write data, not read it.
	
	loop:
	dprintf(fds[1], "%s\n", words[i]);
	---------------------------------
	the parent writes each word in the given array to the writable end of the pipe fds1]
	when all words have been written parent closes fds[1]
	
	waitpid(pid, NULL, 0);
	---------------------
	wait for the termination of a specific child process
	waitpid() is a function used for process management
	NULL arguement is a pointer to an integer where the status of the terminated
		process will be stored. By passing NULL you indicate you are not
		interested in the exit status of the child process.
--------------------------------------------------------------------------------
	In the child process:
	
		dup2(fds[0], STDIN_FILENO);
		--------------------------
		return -1 if error, fd is no error
		
		dup2 will associate stdin(0) with the fds[0], which is the readable
		end of the pipe, but first it will remove stdin(0) reference to
		the standard keyboard file.
		
		the child no longer needs fds[0] and fds[1] created by pipe for the child.
		remember the stdin(0) of child is associated with fd(0) of pipe.
		stdout(1) of child is associated with standard screen.
		
		char *argv[] = {(char *)"sort", NULL};
		-------------------------------------
		
		create an argument vector.
		"sort" string literal of the command to be executed.
		'NULL' is the last element in the 'argv' array, its a convention.
		This 'argv' array can then be used with function like 'execvp' to
		execute the specified command.
		
		if (execvp(argv[0], argv) < 0) exit(0);
		--------------------------------------
		only returns -1, if fail, no values for success
		
		replaces the current process image with program specified in argv[0]
		therefore sort command will be executed
		
		child process finishes after the execvp() function, sorting is done,
		closes its default file descriptors 0,1,2 automatically.
		
--------------------------------------------------------------------------------

I/O redirection:
	< input redirection
	> output redirection
	>> append data to an output file, instead of overwriting
		

	$ < words.txt sort > words2.txt
	input redirection from words.txt,	sort	, output redirection to words2.txt
	
	int fdin = open(inputFile, O_RDONLY, 0644);
		call open() on the file
		and assign that data stream to the file descriptor that open() uses

	dup2(fdin, STDIN_FILENO);
		use dup2() to allow stdin to read that file's contents as input
		
	do the same to write data to file, 
	by allowing stdout to read from pipe

	note fd assigned by open()_file_read is 3.
	once you redirec stdin to handle the data that fd(3) handles,
	close fd(3)
	now when you open()_file_write, fd assigned will be 3,
	because 3 is the lowest available, since it was closed
	
chatgpt: https://chat.openai.com/share/9fd4ddad-1bee-40e9-a708-51615ced111a		

--------------------------------------------------------------------------------

When to use dup2() function

	If you want to read from standard input stream 'stdin'
	then use dup2() to duplicate the fd[0] of child process with 'stdin'
	therefore you can read from keyboard using scanf() function, 
	not using read() function, which you cannot in this case.
	
	close(fd[1]); // close the write end in the child
	
	dup2(fd[0], 0); // redirect stdin to read from the pipe
			// fd[0] is closed automatically
			
	scanf("%s", buffer);
	printf("%s\n",buffer);
	
When you don't need dup2(), as far as I understand

	if you are reading directly from the read end of the pipe,
	you don't need dup2()
	
	close(fd[1]); //close the write end in the child
	close(fd[0]); //because I open file into a different fd
	
	int fdo = open("num.txt", O_RDONLY); 
	
	read(fdo, buffer, sizeof(buffer)
	
	but if I want I could've done this -
		dup2(fdo, fd[0]);
		read(fd[0], buffer, sizeof(buffer));
		this would be redundant
		
	When I closed fd[0] before using it in dup2() and read() functions
	it did not throw error, apparently in some systems slot may be used
--------------------------------------------------------------------------------
Bonus
-----

1,	Handle multiple pipes
2,	<< and >> when the first parameter is "here_doc"
	./pipex here_doc LIMITER cmd cmd1 file
	behaves as,
	cmd << LIMITER | cmd1 >> file
	
If I decide to do Bonus, then I can also improve on the Mandatory part,
that can read awk '{print $2, $3}'
this requires ft_split.c modification to recognize everything between '' as a word,
and ignore spaces between ''. I think I must include '' as part of the flag for execve().
	
	
	
	
	


	

	
	
		

